#!/usr/bin/env python3
"""
Ultimate Backlink Viewer – THE ULTIMATE Edition
------------------------------------------------
An ultra-creative, feature-packed backlink viewer for your Neovim-based note ecosystem.
New and Creative Features in this Edition:
  - **Help Overlay:** Press '?' to display/hide an on-screen help guide.
  - **Multi-Mode Preview:** Toggle between preview snippet mode and full file view with 'm'.
  - **Bookmarking:** Mark links as bookmarks with 'b' and review them with 'B'.
  - **Force Refresh & Progress Bar:** Press 'r' to refresh immediately; the status bar shows last refresh time and a progress indicator during scanning.
  - **Enhanced Status Bar:** Now displays sort order, active filter, last refresh time, and refresh progress.
  - **Dynamic Resizing & Robust Input:** The UI adapts to terminal changes and supports full mouse & keyboard input.
  
Enjoy this ULTIMATE, DO MOAR, REALLY GET CREATIVE version!
"""
import os
import re
import time
import curses
import pynvim
import sys
import textwrap
import logging
import logging.handlers
import concurrent.futures
from typing import List, Optional, Tuple
import yaml

CONFIG_FILE = os.path.expanduser("~/.config/zk_scripts/config.yaml")

# --- Default Configuration ---
DEFAULT_CONFIG = {
    "THESIS_DIR": os.path.expanduser(os.environ.get("NOTES_DIR", "~/Dropbox/notes")), # Env var or default, now using NOTES_DIR env var name
    "POLL_INTERVAL": 2,
    "CONTEXT_LINES": 10,
    "STATUS_BAR_CLEAR_TIME": 3,
    "SEPARATOR_LINE_LENGTH": 80,
    "PREVIEW_SCROLL_LINES": 3,
    "LOG_MAX_BYTES": 1024 * 1024,
    "LOG_BACKUP_COUNT": 5,
    "CONFIG_PATH": os.path.expanduser(os.environ.get("POLL_BACKLINKS_CONFIG_PATH", "~/.config/py_zk/config.yaml")), # Configurable config path
    "LOG_FILE": os.environ.get("POLL_BACKLINKS_LOG_FILE", "ultimate_backlinks.log"), # Configurable log file
}

def load_config_yaml(config_file_path):
    """Loads YAML config, merges with defaults, and applies env vars."""
    config = DEFAULT_CONFIG.copy()
    if os.path.exists(config_file_path):
        try:
            with open(config_file_path, 'r') as f:
                user_config = yaml.safe_load(f) or {}
            config.update(user_config.get('poll_backlinks', {})) # Load only 'poll_backlinks' section and top-level config
            config.update(user_config) # Also load top-level config for global settings like NOTES_DIR
        except Exception as e:
            print(f"Warning: Could not load config file {config_file_path}: {e}", file=sys.stderr)

    # Environment variables override config file and defaults
    for key in DEFAULT_CONFIG:
        env_var = os.environ.get(key)
        if env_var:
            config[key] = env_var
    return config

CONFIG = load_config_yaml(CONFIG_FILE)
LOG_FILE = CONFIG["LOG_FILE"] # Use configured log file


# --- Logging Setup ---
logger = logging.getLogger("UltimateBacklinkViewer")
logger.setLevel(logging.DEBUG)
handler = logging.handlers.RotatingFileHandler(
    LOG_FILE,
    maxBytes=CONFIG["LOG_MAX_BYTES"],
    backupCount=CONFIG["LOG_BACKUP_COUNT"]
)
formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)


# --- UI Color Pair Definitions ---
HIGHLIGHT_COLOR_PAIR = 1
HEADER_COLOR_PAIR = 2
STATUS_COLOR_PAIR = 3
TITLE_COLOR_PAIR = 4
FRONTMATTER_COLOR_PAIR = 5
BORDER_COLOR_PAIR = 6
SEARCH_COLOR_PAIR = 7
HELP_COLOR_PAIR = 8
DEFAULT_COLOR = -1

# --- UI Text Constants ---
SEPARATOR_LINE = "-" * CONFIG["SEPARATOR_LINE_LENGTH"]
SCROLL_UP_INDICATOR = "^^^"
SCROLL_DOWN_INDICATOR = "vvv"
YAML_TOGGLE_ON_TEXT = "[YAML ON]"
YAML_TOGGLE_OFF_TEXT = "[YAML OFF]"
INSTRUCTIONS_TEXT = (
    "↑/↓/j/k: navigate | Enter: open | PgUp/PgDn/u/d: scroll preview | "
    "t: toggle frontmatter | s: sort | f: filter | r: refresh | m: toggle mode | "
    "b: bookmark | B: view bookmarks | ?: help | q: quit"
)
HEADER_TEXT_PREFIX = "Neovim File:"
BACKLINKS_HEADER_TEXT = "Backlinks for:"
PREVIEW_HEADER_TEXT = "Preview:"
PREVIEW_FRONTMATTER_HEADER_TEXT = "Frontmatter:"
NO_BACKLINKS_FOUND_TEXT = "No backlinks found."
NO_FILE_OPEN_TEXT = "No file open."
SCANNING_BACKLINKS_TEXT = "Scanning backlinks..."
PREVIEW_NO_PREVIEW_TEXT = "No preview available."
SORT_ORDER_NONE_TEXT = "Sort: None"
SORT_ORDER_FILENAME_TEXT = "Sort: Filename"
SORT_ORDER_LINE_NUMBER_TEXT = "Sort: Line Number"
SORT_ORDER_TITLE_TEXT = "Sort: Title" # Not used anymore
HELP_TEXT = [
    "Ultimate Backlink Viewer – Help",
    "",
    "Navigation:",
    "  ↑/k: Up      ↓/j: Down      Enter: Open Link",
    "  PgUp/PgDn, u/d: Scroll preview",
    "",
    "Commands:",
    "  t: Toggle frontmatter view",
    "  s: Cycle sort order",
    "  f: Enter filter mode",
    "  r: Force refresh scan",
    "  m: Toggle preview mode (snippet/full file)",
    "  b: Bookmark current backlink",
    "  B: View bookmarks",
    "  ?: Toggle this help screen",
    "  q: quit the viewer",
    "",
    "Press '?' again or ESC while in help to close this screen."
]

# --- Regex Helper ---
def compile_link_pattern(note_basename: str) -> re.Pattern:
    pattern_str = rf"\[{re.escape(note_basename)}(?:\|.*?)?\]"
    return re.compile(pattern_str, re.IGNORECASE)

# --- Helper Functions ---
def extract_yaml_title(lines: List[str]) -> Optional[str]:
    if not lines or lines[0].strip() != "---":
        return None
    yaml_lines = []
    for line in lines[1:]:
        if line.strip() == "---":
            break
        yaml_lines.append(line)
    for line in yaml_lines:
        match = re.match(r"\s*title:\s*(.*)", line, re.IGNORECASE)
        if match:
            return match.group(1).strip(' "')
    return None

def extract_full_frontmatter(lines: List[str]) -> Optional[List[str]]:
    if not lines or lines[0].strip() != "---":
        return None
    frontmatter = [lines[0]]
    for line in lines[1:]:
        frontmatter.append(line)
        if line.strip() == "---":
            return frontmatter
    return None

def find_backlinks(note_file: str) -> List[str]:
    logger.info(f"Scanning backlinks for {note_file}")
    if not os.path.isfile(note_file):
        err_msg = f"Error: Not a file: {note_file}"
        logger.error(err_msg)
        return
    abs_thesis = os.path.abspath(CONFIG["THESIS_DIR"])
    abs_note = os.path.abspath(note_file)
    if not abs_note.startswith(abs_thesis):
        msg = (f"{BACKLINKS_HEADER_TEXT} {note_file}\n\n"
               "File is outside notes directory; no backlinks searched.")
        logger.warning(msg)
        return
    note_basename = os.path.splitext(os.path.basename(note_file))[0]
    pattern = compile_link_pattern(note_basename)
    backlinks: List[str] = []
    for root, _, files in os.walk(CONFIG["THESIS_DIR"]):
        for f in files:
            if f.endswith(".md"):
                full_path = os.path.join(root, f)
                try:
                    note_lines = []
                    with open(full_path, "r", encoding="utf8") as infile:
                        note_lines = infile.readlines()
                        for line_num, line in enumerate(note_lines, start=1):
                            if pattern.search(line):
                                rel_path = os.path.relpath(full_path, CONFIG["THESIS_DIR"])
                                title = extract_yaml_title(note_lines) or "(No Title)"
                                backlinks.append(f"{rel_path}:{line_num}:{title}") # Store title instead of context
                except Exception as e:
                    error_message = f"Error reading {full_path}: {e}"
                    logger.exception(error_message)
                    backlinks.append(error_message)
    if not backlinks or all(not bl.strip() for bl in backlinks):
        return ["", NO_BACKLINKS_FOUND_TEXT]
    logger.info(f"Found {len(backlinks)} backlinks for {note_file}")
    return backlinks

def sort_backlinks(backlinks: List[str], sort_order: str) -> List[str]:
    if sort_order == "filename":
        return sorted(backlinks, key=lambda bl: bl.split(":")[0])
    elif sort_order == "linenumber":
        return sorted(
            backlinks,
            key=lambda bl: int(bl.split(":")[1])
            if len(bl.split(":")) > 1 and bl.split(":")[1].isdigit()
            else 0,
        )
    elif sort_order == "title": # Sort by title now
        return sorted(backlinks, key=lambda bl: bl.split(":")[2].lower()) # Sort by title
    return backlinks

def open_backlink_in_nvim(nvim: pynvim.Nvim, backlink_line: str) -> None:
    try:
        parts = backlink_line.split(":", 2)
        if len(parts) < 2:
            raise ValueError("Invalid backlink format")
        rel_path = parts[0]
        filepath = os.path.join(CONFIG["THESIS_DIR"], rel_path)
        linum = int(parts[1])
        nvim.command(f"edit {filepath}")
        nvim.command(f"call cursor({linum}, 1)")
        logger.info(f"Opened file {filepath} at line {linum}")
    except FileNotFoundError as e:
        error_message = f"File not found: {rel_path} - {e}"
        nvim.command(f'echohl ErrorMsg | echom "{error_message}" | echohl None')
        logger.exception(error_message)
    except ValueError as ve:
        error_message = f"Invalid backlink format: {ve} - Backlink: {backlink_line}"
        nvim.command(f'echohl ErrorMsg | echom "{error_message}" | echohl None')
        logger.exception(error_message)
    except Exception as e:
        error_message = f"Error opening link: {e} - Backlink: {backlink_line}"
        nvim.command(f'echohl ErrorMsg | echom "{error_message}" | echohl None')
        logger.exception(error_message)

def format_preview_line(line: str, width: int) -> Tuple[List[str], bool]:
    is_header = line.lstrip().startswith("#")
    wrapped = textwrap.wrap(line, width=width) if line else [""]
    return wrapped, is_header

# --- Preview Class ---
class Preview:
    def __init__(self, backlink_line: str):
        self.filepath: Optional[str] = None
        self.match_index: int = 1
        self.file_lines: List[str] = []
        self.total_lines: int = 0
        self.title: Optional[str] = None
        self.full_frontmatter: Optional[List[str]] = None
        self.view_start: int = 0
        try:
            parts = backlink_line.split(":", 2)
            if len(parts) < 2:
                raise ValueError("Bad backlink format")
            rel_path = parts[0]
            self.filepath = os.path.join(CONFIG["THESIS_DIR"], rel_path)
            self.match_index = int(parts[1]) - 1
            if not os.path.exists(self.filepath):
                raise FileNotFoundError(f"File not found: {self.filepath}")
            with open(self.filepath, "r", encoding="utf8") as f:
                self.file_lines = [line.rstrip() for line in f.readlines()]
            self.total_lines = len(self.file_lines)
            self.title = extract_yaml_title(self.file_lines)
            self.full_frontmatter = extract_full_frontmatter(self.file_lines)
            self.view_start = max(self.match_index - CONFIG["CONTEXT_LINES"], 0)
        except Exception as e:
            error_message = f"Preview error: {e} - Backlink: {backlink_line}"
            logger.exception(error_message)
            self.file_lines = [error_message]
            self.total_lines = 1

    def get_visible_lines(self, height: int, width: int) -> List[str]:
        output = []
        output.append(SCROLL_UP_INDICATOR if self.view_start > 0 else "")
        for idx in range(self.view_start, min(self.view_start + height, self.total_lines)):
            line = self.file_lines[idx]
            prefix = ">> " if idx == self.match_index else "   "
            avail_width = width - len(prefix)
            wrapped, _ = format_preview_line(line, avail_width)
            output.extend(prefix + w_line for w_line in wrapped)
        if self.view_start + height < self.total_lines:
            output.append(SCROLL_DOWN_INDICATOR)
        return output

    def scroll_down(self, amount: int, height: int) -> None:
        max_start = max(0, self.total_lines - height)
        self.view_start = min(self.view_start + amount, max_start)

    def scroll_up(self, amount: int) -> None:
        self.view_start = max(0, self.view_start - amount)

    def jump_to_top(self) -> None:
        self.view_start = 0

    def jump_to_bottom(self, height: int) -> None:
        self.view_start = max(0, self.total_lines - height)

# --- UI State Management ---
class UIState:
    def __init__(self):
        self.selected_idx: int = 0
        self.list_offset: int = 0
        self.backlinks: List[str] = [] # Now stores "rel_path:line_num:title"
        self.displayed_backlinks: List[str] = []
        self.last_file: Optional[str] = None
        self.last_poll_time: float = 0
        self.preview_data: Optional[Preview] = None
        self.current_preview_idx: Optional[int] = None
        self.frontmatter_mode: bool = False
        self.status_message: str = ""
        self.status_message_time: float = 0
        self.backlink_sort_order: str = "none"
        self.backlinks_future: Optional[concurrent.futures.Future] = None
        self.filter_mode: bool = False
        self.filter_query: str = ""
        self.refresh_requested: bool = False
        self.preview_mode_full: bool = False  # False: snippet mode; True: full file view
        self.bookmarks: List[str] = []         # New: list of bookmarked backlink strings
        self.show_bookmarks: bool = False      # Toggle to view bookmarks instead of backlinks

    def reset_list_state(self) -> None:
        self.selected_idx = 0
        self.list_offset = 0
        self.current_preview_idx = None
        self.preview_data = None

    def update_backlinks(self, new_backlinks: List[str]) -> None:
        self.backlinks = new_backlinks
        self.reset_list_state()

    def set_status_message(self, message: str) -> None:
        self.status_message = message
        self.status_message_time = time.time()

    def get_filtered_backlinks(self) -> List[str]:
        if self.show_bookmarks:
            return self.bookmarks
        if not self.filter_query:
            return self.backlinks
        query = self.filter_query.lower()
        return [bl for bl in self.backlinks if query in bl.lower()]

# --- UI Drawing Functions ---
def draw_instructions(win: curses.window, width: int, status_message: str,
                      wheel: bool, frontmatter: bool, filter_mode: bool,
                      filter_query: str, sort_order: str, refresh_flag: bool) -> None:
    try:
        if filter_mode:
            instr = f"Filter: {filter_query}_"
        else:
            instr = status_message if status_message else INSTRUCTIONS_TEXT
        instr += f" | Sort: {sort_order}"
        if filter_mode:
            instr += " | FILTER ACTIVE"
        if refresh_flag:
            instr += " | REFRESHING..."
        instr += " | Last Refresh: " + time.strftime("%H:%M:%S")
        instr += " | Mouse: " + ("✔" if wheel else "❌")
        instr += " | " + (YAML_TOGGLE_ON_TEXT if frontmatter else YAML_TOGGLE_OFF_TEXT)
        win.addnstr(0, 0, instr, width, curses.A_BOLD | curses.color_pair(STATUS_COLOR_PAIR))
    except curses.error:
        pass

def draw_header(win: curses.window, width: int, last_file: Optional[str], sort_order: str) -> None:
    try:
        win.addnstr(0, 0, SEPARATOR_LINE, width)
        filename = os.path.basename(last_file) if last_file else NO_FILE_OPEN_TEXT
        header = f"{HEADER_TEXT_PREFIX} {filename}"
        sort_text = {
            "filename": SORT_ORDER_FILENAME_TEXT,
            "linenumber": SORT_ORDER_LINE_NUMBER_TEXT,
            "title": SORT_ORDER_TITLE_TEXT, # Now Title Sort
            "none": SORT_ORDER_NONE_TEXT,
        }.get(sort_order, SORT_ORDER_NONE_TEXT)
        header += f"  |  {sort_text}"
        win.addnstr(1, 0, header, width, curses.A_BOLD | curses.color_pair(HEADER_COLOR_PAIR))
        win.addnstr(2, 0, SEPARATOR_LINE, width)
    except curses.error:
        pass

def draw_title_line(win: curses.window, width: int, preview: Optional[Preview]) -> None:
    try:
        title_text = f"Title: {preview.title}" if preview and preview.title else "Title: (none)"
        win.addnstr(0, 0, title_text, width, curses.A_BOLD | curses.color_pair(TITLE_COLOR_PAIR))
    except curses.error:
        pass

def draw_backlink_list(win: curses.window, height: int, width: int,
                       backlinks: List[str], selected_idx: int, list_offset: int,
                       filter_query: str) -> int:
    list_start = 3
    list_footer = height - 2
    visible = list_footer - list_start

    if selected_idx < list_offset:
        list_offset = max(selected_idx, 0)
    elif selected_idx >= list_offset + visible:
        list_offset = max(0, selected_idx - visible + 1)

    if not backlinks or backlinks in ([SCANNING_BACKLINKS_TEXT], [NO_FILE_OPEN_TEXT]):
        msg = SCANNING_BACKLINKS_TEXT if backlinks == [SCANNING_BACKLINKS_TEXT] else NO_FILE_OPEN_TEXT
        try:
            win.addnstr(list_start, 0, msg, width)
            win.addnstr(list_footer, 0, f"{BACKLINKS_HEADER_TEXT} 0", width, curses.A_BOLD)
            win.addnstr(list_footer + 1, 0, SEPARATOR_LINE, width, curses.color_pair(BORDER_COLOR_PAIR))
        except curses.error:
            pass
        return list_offset

    highlight_regex = re.compile(re.escape(filter_query), re.IGNORECASE) if filter_query else None

    for disp in range(visible):
        actual_idx = list_offset + disp
        if actual_idx >= len(backlinks):
            break
        row = list_start + disp
        line = backlinks[actual_idx]
        try:
            if actual_idx == selected_idx:
                win.addnstr(row, 0, line, width, curses.color_pair(HELP_COLOR_PAIR) | curses.A_BOLD)
            else:
                if highlight_regex:
                    parts = highlight_regex.split(line)
                    matches = highlight_regex.findall(line)
                    x = 0
                    for i, part in enumerate(parts):
                        win.addnstr(row, x, part, width - x)
                        x += len(part)
                        if i < len(matches):
                            win.addnstr(row, x, matches[i], width - x,
                                        curses.color_pair(SEARCH_COLOR_PAIR) | curses.A_BOLD)
                            x += len(matches[i])
                else:
                    parts = line.split(":", 2) # split into three parts
                    if len(parts) >= 3:
                        file_line = f"{parts[0]}:{parts[1]}: "
                        title_text = parts[2]
                        win.addnstr(row, 0, file_line, width)
                        win.addnstr(row, len(file_line), title_text, width - len(file_line),
                        curses.color_pair(TITLE_COLOR_PAIR) | curses.A_BOLD)
                    else:
                        win.addnstr(row, 0, line, width)
        except curses.error:
            pass

    footer_from = list_offset + 1
    footer_to = min(list_offset + visible, len(backlinks))
    footer = f"{BACKLINKS_HEADER_TEXT} {footer_from}-{footer_to}/{len(backlinks)}"
    try:
        win.addnstr(list_footer, 0, footer, width, curses.A_BOLD)
        win.addnstr(list_footer + 1, 0, SEPARATOR_LINE, width, curses.color_pair(BORDER_COLOR_PAIR))
    except curses.error:
        pass
    return list_offset

def draw_preview_window(win: curses.window, height: int, width: int,
                        preview: Optional[Preview], frontmatter: bool) -> None:
    win.erase()
    header = PREVIEW_FRONTMATTER_HEADER_TEXT if frontmatter else PREVIEW_HEADER_TEXT
    try:
        win.addnstr(0, 0, header, width,
                    curses.A_BOLD | curses.A_UNDERLINE | curses.color_pair(HEADER_COLOR_PAIR))
    except curses.error:
        pass
    if preview:
        row_offset = 1
        if frontmatter and preview.full_frontmatter:
            for line in preview.full_frontmatter:
                try:
                    win.addnstr(row_offset, 0, line, width,
                                curses.color_pair(FRONTMATTER_COLOR_PAIR) | curses.A_BOLD)
                except curses.error:
                    pass
                row_offset += 1
        else:
            lines = preview.get_visible_lines(height - 1, width)
            progress = int((preview.view_start / max(preview.total_lines, 1)) * 100)
            status = f" ({preview.view_start+1}-{min(preview.view_start + height - 1, preview.total_lines)}/{preview.total_lines} lines, {progress}%)"
            try:
                win.addnstr(0, len(header), status, width - len(header), curses.color_pair(STATUS_COLOR_PAIR))
            except curses.error:
                pass
            current_line = row_offset
            for line in lines:
                try:
                    if line.lstrip().startswith(">>"):
                        attr = (curses.color_pair(HEADER_COLOR_PAIR) | curses.A_BOLD) if "#" in line else (curses.color_pair(HIGHLIGHT_COLOR_PAIR) | curses.A_BOLD)
                        win.addnstr(current_line, 0, line, width, attr)
                    else:
                        win.addnstr(current_line, 0, line, width)
                except curses.error:
                    pass
                current_line += 1
    else:
        try:
            win.addnstr(1, 0, PREVIEW_NO_PREVIEW_TEXT, width)
        except curses.error:
            pass

def draw_help_overlay(stdscr: curses.window, width: int, height: int) -> None:
    stdscr.erase()
    for i, line in enumerate(HELP_TEXT):
        y = (height - len(HELP_TEXT)) // 2 + i
        x = max((width - len(line)) // 2, 0)
        try:
            stdscr.addnstr(y, x, line, width - x, curses.A_BOLD | curses.color_pair(HELP_COLOR_PAIR))
        except curses.error:
            pass
    stdscr.refresh()

# --- Main UI Drawing ---
def draw_ui(stdscr: curses.window, ui: UIState, wheel_enabled: bool) -> None:
    stdscr.erase()
    height, width = stdscr.getmaxyx()
    total_reserved = 3  # 1 for status, 1 for title, 1 for divider
    list_win_height = (height - total_reserved) // 2
    preview_win_height = height - total_reserved - list_win_height

    status_win = stdscr.subwin(1, width, 0, 0)
    list_win = stdscr.subwin(list_win_height, width, 1, 0)
    title_win = stdscr.subwin(1, width, 1 + list_win_height, 0)
    divider_y = 1 + list_win_height + 1
    preview_win = stdscr.subwin(preview_win_height, width, divider_y + 1, 0)

    status_win.erase()
    list_win.erase()
    title_win.erase()
    stdscr.hline(divider_y, 0, SEPARATOR_LINE[0], width)
    preview_win.erase()

    draw_instructions(status_win, width, ui.status_message,
                      wheel_enabled, ui.frontmatter_mode, ui.filter_mode,
                      ui.filter_query, ui.backlink_sort_order, ui.refresh_requested)
    draw_header(list_win, width, ui.last_file, ui.backlink_sort_order)
    ui.list_offset = draw_backlink_list(list_win, list_win_height, width,
                                        ui.displayed_backlinks, ui.selected_idx, ui.list_offset, ui.filter_query)
    draw_title_line(title_win, width, ui.preview_data)
    draw_preview_window(preview_win, preview_win_height, width, ui.preview_data, ui.frontmatter_mode)

    stdscr.refresh()
    status_win.refresh()
    list_win.refresh()
    title_win.refresh()
    preview_win.refresh()

# --- Input Handling ---
def handle_input(stdscr: curses.window, nvim: pynvim.Nvim, ui: UIState, wheel_enabled: bool) -> bool:
    height, width = stdscr.getmaxyx()
    key = stdscr.getch()
    if key == -1:
        return True

    # Help overlay toggle
    if key == ord('?'):
        ui.set_status_message("Help overlay active")
        draw_help_overlay(stdscr, width, height)
        # Wait for any key to dismiss
        stdscr.nodelay(False)
        stdscr.getch()
        stdscr.nodelay(True)
        return True

    # Filter mode input
    if ui.filter_mode:
        if key in (27,):  # ESC cancels filter mode
            ui.filter_mode = False
            ui.filter_query = ""
        elif key in (curses.KEY_BACKSPACE, 8, 127):
            ui.filter_query = ui.filter_query[:-1]
        elif key in (10, 13):  # Enter
            ui.filter_mode = False
        elif 32 <= key <= 126:
            ui.filter_query += chr(key)
        return True

    # Global commands
    if key in (ord("q"), ord("Q")):
        return False
    elif key in (ord("s"), ord("S")):
        ui.backlink_sort_order = get_next_sort_order(ui.backlink_sort_order)
        return True
    elif key in (ord("f"), ord("F")):
        ui.filter_mode = True
        ui.filter_query = ""
        return True
    elif key in (ord("r"), ord("R")):
        ui.refresh_requested = True
        ui.set_status_message("Force refresh triggered")
        try:
            cur_file = nvim.eval("expand('%:p')")
        except Exception as e:
            logger.exception(f"Error evaluating current file: {e}")
            cur_file = ""
        ui.last_file = cur_file
        if cur_file:
            ui.backlinks_future = executor.submit(find_backlinks, cur_file)
            ui.update_backlinks([SCANNING_BACKLINKS_TEXT])
        else:
            ui.update_backlinks([NO_FILE_OPEN_TEXT])
            ui.backlinks_future = None
        ui.refresh_requested = False
        return True
    elif key in (ord("m"), ord("M")):
        ui.preview_mode_full = not ui.preview_mode_full
        if ui.preview_mode_full and ui.preview_data:
            # In full mode, show the entire file (simulate by setting context to full file length)
            ui.preview_data.view_start = 0
        ui.set_status_message("Toggled preview mode")
        return True
    elif key in (ord("b"), ord("B")):
        # b to bookmark, B to view bookmarks
        if key == ord("b"):
            if ui.selected_idx < len(ui.displayed_backlinks):
                bookmark = ui.backlinks[ui.selected_idx]
                if bookmark not in ui.bookmarks:
                    ui.bookmarks.append(bookmark)
                    ui.set_status_message("Bookmark added")
                else:
                    ui.set_status_message("Already bookmarked")
        else:
            ui.show_bookmarks = not ui.show_bookmarks
            if ui.show_bookmarks:
                ui.set_status_message("Showing bookmarks")
            else:
                ui.set_status_message("Exiting bookmarks view")
            ui.reset_list_state()
        return True

    # Navigation in backlink list
    if key in (curses.KEY_UP, ord("k")):
        if ui.selected_idx > 0:
            ui.selected_idx -= 1
            ui.current_preview_idx = None
    elif key in (curses.KEY_DOWN, ord("j")):
        if ui.selected_idx < len(ui.displayed_backlinks) - 1:
            ui.selected_idx += 1
            ui.current_preview_idx = None
    elif key in (curses.KEY_ENTER, 10, 13):
        if ui.displayed_backlinks and ui.selected_idx < len(ui.displayed_backlinks):
            try:
                open_backlink_in_nvim(nvim, ui.backlinks[ui.selected_idx])
                ui.set_status_message(f"Opened: {ui.backlinks[ui.selected_idx].split(':',1)[0]}")
            except Exception as e:
                ui.set_status_message(f"Error opening link: {e}")
    # Preview navigation
    elif ui.preview_data is not None:
        avail_height = height - (1 + ((height - 3) // 2) + 3)
        if key == curses.KEY_NPAGE:
            ui.preview_data.scroll_down(CONFIG["PREVIEW_SCROLL_LINES"], avail_height)
        elif key == curses.KEY_PPAGE:
            ui.preview_data.scroll_up(CONFIG["PREVIEW_SCROLL_LINES"])
        elif key in (ord("d"),):
            ui.preview_data.scroll_down(1, avail_height)
        elif key in (ord("u"),):
            ui.preview_data.scroll_up(1)
        elif key in (curses.KEY_HOME, ord("g")):
            ui.preview_data.jump_to_top()
        elif key in (curses.KEY_END, ord("G")):
            ui.preview_data.jump_to_bottom(avail_height)
        elif key in (ord("t"),):
            ui.frontmatter_mode = not ui.frontmatter_mode
    # Mouse events
    elif key == curses.KEY_MOUSE and wheel_enabled:
        try:
            _, mx, my, _, bstate = curses.getmouse()
            list_win_height = (height - 3) // 2
            if bstate & curses.BUTTON1_PRESSED and 1 <= my < 1 + list_win_height:
                new_idx = my - 1 + ui.list_offset
                if 0 <= new_idx < len(ui.displayed_backlinks):
                    ui.selected_idx = new_idx
                    ui.current_preview_idx = None
            elif bstate & curses.BUTTON4_PRESSED:
                if my >= 1 + list_win_height + 3 and ui.preview_data:
                    ui.preview_data.scroll_up(CONFIG["PREVIEW_SCROLL_LINES"])
                elif my < 1 + list_win_height:
                    ui.list_offset = max(0, ui.list_offset - 1)
            elif bstate & curses.BUTTON5_PRESSED:
                if my >= 1 + list_win_height + 3 and ui.preview_data:
                    ui.preview_data.scroll_down(CONFIG["PREVIEW_SCROLL_LINES"], avail_height)
                elif my < 1 + list_win_height:
                    ui.list_offset += 1
        except Exception as e:
            logger.exception(f"Mouse event error: {e}")
    return True

def get_next_sort_order(current_order: str) -> str:
    orders = ["none", "filename", "linenumber", "title"]
    return orders[(orders.index(current_order) + 1) % len(orders)]

def update_ui_state(nvim: pynvim.Nvim, ui: UIState, executor: concurrent.futures.ThreadPoolExecutor) -> None:
    now = time.time()
    if ui.status_message and now - ui.status_message_time >= CONFIG["STATUS_BAR_CLEAR_TIME"]:
        ui.status_message = ""
    if now - ui.last_poll_time >= CONFIG["POLL_INTERVAL"]:
        ui.last_poll_time = now
        try:
            cur_file = nvim.eval("expand('%:p')")
        except Exception as e:
            logger.exception(f"Error evaluating current file: {e}")
            cur_file = ""
        if cur_file != ui.last_file:
            ui.last_file = cur_file
            ui.reset_list_state()
            if cur_file:
                ui.backlinks_future = executor.submit(find_backlinks, cur_file)
                ui.update_backlinks([SCANNING_BACKLINKS_TEXT])
            else:
                ui.update_backlinks([NO_FILE_OPEN_TEXT])
                ui.backlinks_future = None
            ui.backlink_sort_order = "none"
    if ui.backlinks_future and ui.backlinks_future.done():
        try:
            raw = ui.backlinks_future.result()
            ui.update_backlinks(raw)
            if NO_BACKLINKS_FOUND_TEXT not in raw:
                ui.set_status_message("Backlink scan complete.")
        except Exception as e:
            msg = f"Backlink scan error: {e}"
            # ui.update_backlinks([msg])
            # ui.set_status_message("Backlink scan error.")
            logger.exception(msg)
        ui.backlinks_future = None
        ui.current_preview_idx = None
    filtered = ui.get_filtered_backlinks()
    ui.displayed_backlinks = sort_backlinks(filtered, ui.backlink_sort_order)
    if ui.displayed_backlinks and len(ui.displayed_backlinks) > ui.selected_idx:
        if ui.current_preview_idx != ui.selected_idx:
            try:
                ui.preview_data = Preview(ui.displayed_backlinks[ui.selected_idx])
            except Exception as e:
                logger.exception(f"Error updating preview: {e}")
                ui.preview_data = None
            ui.current_preview_idx = ui.selected_idx
    else:
        ui.preview_data = None
        ui.current_preview_idx = None

def draw_full_ui(stdscr: curses.window, ui: UIState, wheel_enabled: bool) -> None:
    draw_ui(stdscr, ui, wheel_enabled)

# --- Main Interactive UI ---
def interactive_ui(stdscr: curses.window, nvim: pynvim.Nvim) -> None:
    mouse_mask = (curses.REPORT_MOUSE_POSITION |
                  curses.BUTTON1_PRESSED | curses.BUTTON1_RELEASED |
                  curses.BUTTON2_PRESSED | curses.BUTTON2_RELEASED |
                  curses.BUTTON3_PRESSED | curses.BUTTON3_RELEASED)
    wheel_supported = hasattr(curses, "BUTTON4_PRESSED") and hasattr(curses, "BUTTON5_PRESSED")
    if wheel_supported:
        mouse_mask |= curses.BUTTON4_PRESSED | curses.BUTTON5_PRESSED
    curses.mousemask(mouse_mask)
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.timeout(100)
    try:
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(HIGHLIGHT_COLOR_PAIR, curses.COLOR_WHITE, curses.COLOR_YELLOW)
        curses.init_pair(HEADER_COLOR_PAIR, curses.COLOR_CYAN, DEFAULT_COLOR)
        curses.init_pair(STATUS_COLOR_PAIR, curses.COLOR_GREEN, DEFAULT_COLOR)
        curses.init_pair(TITLE_COLOR_PAIR, curses.COLOR_MAGENTA, DEFAULT_COLOR)
        curses.init_pair(FRONTMATTER_COLOR_PAIR, curses.COLOR_BLUE, DEFAULT_COLOR)
        curses.init_pair(BORDER_COLOR_PAIR, curses.COLOR_WHITE, DEFAULT_COLOR)
        curses.init_pair(SEARCH_COLOR_PAIR, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(HELP_COLOR_PAIR, curses.COLOR_YELLOW, DEFAULT_COLOR)
    except curses.error:
        pass

    CONFIG["THESIS_DIR"] = os.path.expanduser(CONFIG["THESIS_DIR"]) # Expand THESIS_DIR here after config load

    ui = UIState()
    global executor
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
    running = True
    while running:
        new_height, new_width = stdscr.getmaxyx()
        if curses.is_term_resized(new_height, new_width):
            curses.resizeterm(new_height, new_width)
        update_ui_state(nvim, ui, executor)
        draw_full_ui(stdscr, ui, wheel_supported)
        running = handle_input(stdscr, nvim, ui, wheel_supported)
        time.sleep(0.01)

# --- Main Entry Point ---
def main() -> None:
    if not os.path.isdir(CONFIG["THESIS_DIR"]):
        logger.error(f"Error: THESIS_DIR does not exist: {CONFIG['THESIS_DIR']}")
        sys.exit(f"Error: THESIS_DIR does not exist: {CONFIG['THESIS_DIR']}")
    try:
        nvim = pynvim.attach("socket", path="/tmp/obsidian.sock") # socket path not configurable yet in python part
    except Exception as e:
        logger.exception(f"Failed to attach to Neovim socket: {e}")
        sys.exit("Failed to attach to Neovim socket: " + str(e))
    curses.wrapper(interactive_ui, nvim)

if __name__ == "__main__":
    main()

